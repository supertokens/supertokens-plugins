import fs from "fs";
import path from "path";

interface IconData {
  name: string;
  dataUrl: string;
}

function optimizeSvg(svgContent: string): string {
  return (
    svgContent
      .replace(/\s+/g, " ")
      .replace(/>\s+</g, "><")
      .replace(/<!--.*?-->/g, "")
      .replace(/\s*xmlns:.*?=".*?"/g, "")
      .replace(/\s*xml:.*?=".*?"/g, "")
      // Fix background rectangles by setting fill-opacity to 0
      .replace(/fill-opacity="0\.01"/g, 'fill-opacity="0"')
      .replace(/fill-opacity="0\.02"/g, 'fill-opacity="0"')
      .replace(/fill-opacity="0\.03"/g, 'fill-opacity="0"')
      .replace(/fill-opacity="0\.04"/g, 'fill-opacity="0"')
      .replace(/fill-opacity="0\.05"/g, 'fill-opacity="0"')
      // Also handle any other small opacity values that might cause borders
      .replace(/fill-opacity="0\.[0-9]+"/g, 'fill-opacity="0"')
      // Remove fill from transparent rectangles to be extra safe
      .replace(/<rect([^>]*)fill-opacity="0"([^>]*)fill="[^"]*"([^>]*)>/g, '<rect$1fill-opacity="0"$2$3>')
      .replace(/<rect([^>]*)fill="[^"]*"([^>]*)fill-opacity="0"([^>]*)>/g, '<rect$1$2fill-opacity="0"$3>')
      // Replace hardcoded colors with currentColor for theming
      .replace(/fill="#[0-9a-fA-F]{6}"/g, 'fill="currentColor"')
      .replace(/fill="#[0-9a-fA-F]{3}"/g, 'fill="currentColor"')
      .replace(/stroke="#[0-9a-fA-F]{6}"/g, 'stroke="currentColor"')
      .replace(/stroke="#[0-9a-fA-F]{3}"/g, 'stroke="currentColor"')
      // Replace common color names with currentColor
      .replace(/fill="black"/g, 'fill="currentColor"')
      .replace(/stroke="black"/g, 'stroke="currentColor"')
      // Remove stroke from the root SVG element to prevent borders (keep on individual elements)
      .replace(/(<svg[^>]*)\s+stroke="[^"]*"([^>]*>)/g, "$1$2")
      .replace(/(<svg[^>]*)\s+stroke-width="[^"]*"([^>]*>)/g, "$1$2")
      // Remove empty groups and definitions
      .replace(/<g[^>]*><\/g>/g, "")
      .replace(/<defs[^>]*><\/defs>/g, "")
      .trim()
  );
}

function processIcons(iconsDir: string): IconData[] {
  if (!fs.existsSync(iconsDir)) {
    console.warn(`Icons directory not found: ${iconsDir}`);
    return [];
  }

  const iconFiles = fs.readdirSync(iconsDir).filter((file) => file.endsWith(".svg") && !file.startsWith("."));

  if (iconFiles.length === 0) {
    console.warn(`No SVG files found in: ${iconsDir}`);
    return [];
  }

  console.log(`Processing ${iconFiles.length} icons...`);

  return iconFiles.map((file) => {
    const filePath = path.join(iconsDir, file);
    const svgContent = fs.readFileSync(filePath, "utf-8");

    // Optimize SVG content
    const optimizedSvg = optimizeSvg(svgContent);

    // Create data URL
    const dataUrl = `data:image/svg+xml,${encodeURIComponent(optimizedSvg)}`;

    const iconName = path.basename(file, ".svg");
    console.log(`  âœ“ Processed: ${iconName}`);

    return {
      name: iconName,
      dataUrl,
    };
  });
}

function generateIconRegistry() {
  const iconsDir = path.join(__dirname, "../src/icons");
  const outputDir = path.join(__dirname, "../src/components/icon");
  const outputFile = path.join(outputDir, "icon-registry.ts");

  // Ensure output directory exists
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Process icons
  const icons = processIcons(iconsDir);

  // Generate TypeScript file
  const registryContent = `// Auto-generated icon registry
// This file is generated by build-scripts/process-icons.ts
// Do not edit manually - add SVG files to src/icons/ instead

export interface IconData {
  name: string;
  dataUrl: string;
}

export const iconRegistry: IconData[] = ${JSON.stringify(icons, null, 2)};

export const availableIcons = [
${icons.map((icon) => `  '${icon.name}'`).join(",\n")}
] as const;

export type AvailableIconName = typeof availableIcons[number];
`;

  fs.writeFileSync(outputFile, registryContent);
  console.log(`Generated icon registry: ${outputFile}`);
  console.log(`Total icons: ${icons.length}`);
}

// Run the script
generateIconRegistry();
